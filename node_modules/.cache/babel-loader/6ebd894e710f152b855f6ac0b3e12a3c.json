{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar DataChecker = require('./DataChecker');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayProfiler = require('../util/RelayProfiler');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar _require = require('./RelayModernSelector'),\n    createReaderSelector = _require.createReaderSelector;\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 0;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore =\n/*#__PURE__*/\nfunction () {\n  function RelayModernStore(source, options) {\n    var _ref, _ref2, _ref3, _ref4; // Prevent mutation of a record from outside the store.\n\n\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._connectionEvents = new Map();\n    this._connectionSubscriptions = new Map();\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_ref = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _ref !== void 0 ? _ref : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcScheduler = (_ref2 = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _ref2 !== void 0 ? _ref2 : resolveImmediate;\n    this._getDataID = (_ref3 = options === null || options === void 0 ? void 0 : options.UNSTABLE_DO_NOT_USE_getDataID) !== null && _ref3 !== void 0 ? _ref3 : defaultGetDataID;\n    this._hasScheduledGC = false;\n    this._index = 0;\n    this._operationLoader = (_ref4 = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _ref4 !== void 0 ? _ref4 : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._subscriptions = new Set();\n    this._updatedConnectionIDs = {};\n    this._updatedRecordIDs = {};\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto.getConnectionEvents_UNSTABLE = function getConnectionEvents_UNSTABLE(connectionID) {\n    var events = this._connectionEvents.get(connectionID);\n\n    if (events != null) {\n      var _events$optimistic;\n\n      return (_events$optimistic = events.optimistic) !== null && _events$optimistic !== void 0 ? _events$optimistic : events[\"final\"];\n    }\n  };\n\n  _proto.check = function check(selector) {\n    var _this = this;\n\n    var _this$_optimisticSour2;\n\n    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n    return DataChecker.check(source, source, selector, [], this._operationLoader, this._getDataID, function (id) {\n      return _this.getConnectionEvents_UNSTABLE(id);\n    });\n  };\n\n  _proto.retain = function retain(selector) {\n    var _this2 = this;\n\n    var index = this._index++;\n\n    var dispose = function dispose() {\n      // When disposing, move the selector onto the release buffer\n      _this2._releaseBuffer.push(index); // Only when the release buffer is full do we actually\n      // release the selector and run GC\n\n\n      if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n        var idx = _this2._releaseBuffer.shift();\n\n        _this2._roots[\"delete\"](idx);\n\n        _this2._scheduleGC();\n      }\n    };\n\n    this._roots.set(index, selector);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners form the subscriptions\n  ;\n\n  _proto.notify = function notify() {\n    var _this3 = this;\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n\n    this._connectionSubscriptions.forEach(function (subscription, id) {\n      if (subscription.stale) {\n        subscription.stale = false;\n        subscription.callback(subscription.snapshot);\n      }\n    });\n\n    this._updatedConnectionIDs = {};\n    this._updatedRecordIDs = {};\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source) {\n    var _this4 = this;\n\n    var _this$_optimisticSour3;\n\n    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;\n    updateTargetFromSource(target, source, this._updatedRecordIDs);\n\n    this._connectionSubscriptions.forEach(function (subscription, id) {\n      var hasStoreUpdates = hasOverlappingIDs(subscription.snapshot.seenRecords, _this4._updatedRecordIDs);\n\n      if (!hasStoreUpdates) {\n        return;\n      }\n\n      var nextSnapshot = _this4._updateConnection_UNSTABLE(subscription.resolver, subscription.snapshot, source, null);\n\n      if (nextSnapshot) {\n        subscription.snapshot = nextSnapshot;\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this5 = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this5._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this6 = this;\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this6._gcHoldCounter > 0) {\n        _this6._gcHoldCounter--;\n\n        if (_this6._gcHoldCounter === 0 && _this6._shouldScheduleGC) {\n          _this6._scheduleGC();\n\n          _this6._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  } // Returns the owner (RequestDescriptor) if the subscription was affected by the\n  // latest update, or null if it was not affected.\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasOverlappingIDs(snapshot.seenRecords, this._updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  _proto.lookupConnection_UNSTABLE = function lookupConnection_UNSTABLE(connectionReference, resolver) {\n    var _connectionEvents$opt;\n\n    !RelayFeatureFlags.ENABLE_CONNECTION_RESOLVERS ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Connection resolvers are not yet supported.') : invariant(false) : void 0;\n    var id = connectionReference.id;\n    var initialState = resolver.initialize();\n\n    var connectionEvents = this._connectionEvents.get(id);\n\n    var events = connectionEvents != null ? (_connectionEvents$opt = connectionEvents.optimistic) !== null && _connectionEvents$opt !== void 0 ? _connectionEvents$opt : connectionEvents[\"final\"] : null;\n    var initialSnapshot = {\n      edgeSnapshots: {},\n      id: id,\n      reference: connectionReference,\n      seenRecords: {},\n      state: initialState\n    };\n\n    if (events == null || events.length === 0) {\n      return initialSnapshot;\n    }\n\n    return this._reduceConnection_UNSTABLE(resolver, connectionReference, initialSnapshot, events);\n  };\n\n  _proto.subscribeConnection_UNSTABLE = function subscribeConnection_UNSTABLE(snapshot, resolver, callback) {\n    var _this7 = this;\n\n    !RelayFeatureFlags.ENABLE_CONNECTION_RESOLVERS ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Connection resolvers are not yet supported.') : invariant(false) : void 0;\n    var id = String(this._index++);\n    var subscription = {\n      backup: null,\n      callback: callback,\n      id: id,\n      resolver: resolver,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this7._connectionSubscriptions[\"delete\"](id);\n    };\n\n    this._connectionSubscriptions.set(id, subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.publishConnectionEvents_UNSTABLE = function publishConnectionEvents_UNSTABLE(events, final) {\n    var _this8 = this;\n\n    if (events.length === 0) {\n      return;\n    }\n\n    !RelayFeatureFlags.ENABLE_CONNECTION_RESOLVERS ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Connection resolvers are not yet supported.') : invariant(false) : void 0;\n    var pendingConnectionEvents = new Map();\n    events.forEach(function (event) {\n      var connectionID = event.connectionID;\n      var pendingEvents = pendingConnectionEvents.get(connectionID);\n\n      if (pendingEvents == null) {\n        pendingEvents = [];\n        pendingConnectionEvents.set(connectionID, pendingEvents);\n      }\n\n      pendingEvents.push(event);\n\n      var connectionEvents = _this8._connectionEvents.get(connectionID);\n\n      if (connectionEvents == null) {\n        connectionEvents = {\n          \"final\": [],\n          optimistic: null\n        };\n\n        _this8._connectionEvents.set(connectionID, connectionEvents);\n      }\n\n      if (final) {\n        connectionEvents[\"final\"].push(event);\n      } else {\n        var optimisticEvents = connectionEvents.optimistic;\n\n        if (optimisticEvents == null) {\n          optimisticEvents = connectionEvents[\"final\"].slice();\n          connectionEvents.optimistic = optimisticEvents;\n        }\n\n        optimisticEvents.push(event);\n      }\n    });\n\n    this._connectionSubscriptions.forEach(function (subscription, id) {\n      var pendingEvents = pendingConnectionEvents.get(subscription.snapshot.reference.id);\n\n      if (pendingEvents == null) {\n        return;\n      }\n\n      var nextSnapshot = _this8._updateConnection_UNSTABLE(subscription.resolver, subscription.snapshot, null, pendingEvents);\n\n      if (nextSnapshot) {\n        subscription.snapshot = nextSnapshot;\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto._updateConnection_UNSTABLE = function _updateConnection_UNSTABLE(resolver, snapshot, source, pendingEvents) {\n    var _pendingEvents;\n\n    var nextSnapshot = this._reduceConnection_UNSTABLE(resolver, snapshot.reference, snapshot, (_pendingEvents = pendingEvents) !== null && _pendingEvents !== void 0 ? _pendingEvents : [], source);\n\n    var state = recycleNodesInto(snapshot.state, nextSnapshot.state);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    if (state !== snapshot.state) {\n      return (0, _objectSpread2[\"default\"])({}, nextSnapshot, {\n        state: state\n      });\n    }\n  };\n\n  _proto._reduceConnection_UNSTABLE = function _reduceConnection_UNSTABLE(resolver, connectionReference, snapshot, events) {\n    var _this9 = this;\n\n    var _edgesField$concreteT;\n\n    var source = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var edgesField = connectionReference.edgesField,\n        id = connectionReference.id,\n        variables = connectionReference.variables;\n    var fragment = {\n      kind: 'Fragment',\n      name: edgesField.name,\n      type: (_edgesField$concreteT = edgesField.concreteType) !== null && _edgesField$concreteT !== void 0 ? _edgesField$concreteT : '__Any',\n      metadata: null,\n      argumentDefinitions: [],\n      selections: edgesField.selections\n    };\n    var seenRecords = {};\n    var edgeSnapshots = (0, _objectSpread2[\"default\"])({}, snapshot.edgeSnapshots);\n    var initialState = snapshot.state;\n\n    if (source) {\n      var edgeData = {};\n      Object.keys(edgeSnapshots).forEach(function (edgeID) {\n        var prevSnapshot = edgeSnapshots[edgeID];\n        var nextSnapshot = RelayReader.read(_this9.getSource(), createReaderSelector(fragment, edgeID, variables, prevSnapshot.selector.owner));\n        var data = recycleNodesInto(prevSnapshot.data, nextSnapshot.data);\n        nextSnapshot = {\n          data: data,\n          isMissingData: nextSnapshot.isMissingData,\n          seenRecords: nextSnapshot.seenRecords,\n          selector: nextSnapshot.selector\n        };\n\n        if (data !== prevSnapshot.data) {\n          edgeData[edgeID] = data;\n          /* $FlowFixMe(>=0.111.0) This comment suppresses an error found when\n           * Flow v0.111.0 was deployed. To see the error, delete this comment\n           * and run Flow. */\n\n          edgeSnapshots[edgeID] = nextSnapshot;\n        }\n      });\n\n      if (Object.keys(edgeData).length !== 0) {\n        initialState = resolver.reduce(initialState, {\n          kind: 'update',\n          edgeData: edgeData\n        });\n      }\n    }\n\n    var state = events.reduce(function (prevState, event) {\n      if (event.kind === 'fetch') {\n        var edges = [];\n        event.edgeIDs.forEach(function (edgeID) {\n          if (edgeID == null) {\n            edges.push(edgeID);\n            return;\n          }\n\n          var edgeSnapshot = RelayReader.read(_this9.getSource(), createReaderSelector(fragment, edgeID, variables, event.request));\n          Object.assign(seenRecords, edgeSnapshot.seenRecords);\n          var itemData = edgeSnapshot.data;\n          /* $FlowFixMe(>=0.111.0) This comment suppresses an error found\n           * when Flow v0.111.0 was deployed. To see the error, delete this\n           * comment and run Flow. */\n\n          edgeSnapshots[edgeID] = edgeSnapshot;\n          edges.push(itemData);\n        });\n        return resolver.reduce(prevState, {\n          kind: 'fetch',\n          args: event.args,\n          edges: edges,\n          pageInfo: event.pageInfo,\n          stream: event.stream\n        });\n      } else if (event.kind === 'insert') {\n        var edgeSnapshot = RelayReader.read(_this9.getSource(), createReaderSelector(fragment, event.edgeID, variables, event.request));\n        Object.assign(seenRecords, edgeSnapshot.seenRecords);\n        var itemData = edgeSnapshot.data;\n        /* $FlowFixMe(>=0.111.0) This comment suppresses an error found when\n         * Flow v0.111.0 was deployed. To see the error, delete this comment\n         * and run Flow. */\n\n        edgeSnapshots[event.edgeID] = edgeSnapshot;\n        return resolver.reduce(prevState, {\n          args: event.args,\n          edge: itemData,\n          kind: 'insert'\n        });\n      } else if (event.kind === 'stream.edge') {\n        var _edgeSnapshot = RelayReader.read(_this9.getSource(), createReaderSelector(fragment, event.edgeID, variables, event.request));\n\n        Object.assign(seenRecords, _edgeSnapshot.seenRecords);\n        var _itemData = _edgeSnapshot.data;\n        /* $FlowFixMe(>=0.111.0) This comment suppresses an error found when\n         * Flow v0.111.0 was deployed. To see the error, delete this comment\n         * and run Flow. */\n\n        edgeSnapshots[event.edgeID] = _edgeSnapshot;\n        return resolver.reduce(prevState, {\n          args: event.args,\n          edge: _itemData,\n          index: event.index,\n          kind: 'stream.edge'\n        });\n      } else if (event.kind === 'stream.pageInfo') {\n        return resolver.reduce(prevState, {\n          args: event.args,\n          kind: 'stream.pageInfo',\n          pageInfo: event.pageInfo\n        });\n      } else {\n        event.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected connection event kind `%s`.', event.kind) : invariant(false) : void 0;\n      }\n    }, initialState);\n    return {\n      edgeSnapshots: edgeSnapshots,\n      id: id,\n      reference: connectionReference,\n      seenRecords: seenRecords,\n      state: state\n    };\n  };\n\n  _proto.snapshot = function snapshot() {\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n\n    this._connectionSubscriptions.forEach(function (subscription) {\n      subscription.backup = subscription.snapshot;\n    });\n\n    this._subscriptions.forEach(function (subscription) {\n      subscription.backup = subscription.snapshot;\n    });\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    var _this10 = this;\n\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    this._optimisticSource = null;\n\n    this._connectionEvents.forEach(function (events) {\n      events.optimistic = null;\n    });\n\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n\n    this._connectionSubscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.state !== subscription.snapshot.state) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = backup;\n      } else {\n        // This subscription was established after the creation of the\n        // connection snapshot so there's nothing to restore to. Recreate the\n        // connection from scratch and check ifs value changes.\n        var baseSnapshot = _this10.lookupConnection_UNSTABLE(subscription.snapshot.reference, subscription.resolver);\n\n        var nextState = recycleNodesInto(subscription.snapshot.state, baseSnapshot.state);\n\n        if (nextState !== subscription.snapshot.state) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = (0, _objectSpread2[\"default\"])({}, baseSnapshot, {\n          state: nextState\n        });\n      }\n    });\n  };\n\n  _proto._scheduleGC = function _scheduleGC() {\n    var _this11 = this;\n\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._hasScheduledGC) {\n      return;\n    }\n\n    this._hasScheduledGC = true;\n\n    this._gcScheduler(function () {\n      _this11.__gc();\n\n      _this11._hasScheduledGC = false;\n    });\n  };\n\n  _proto.__gc = function __gc() {\n    var _this12 = this; // Don't run GC while there are optimistic updates applied\n\n\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var references = new Set();\n    var connectionReferences = new Set(); // Mark all records that are traversable from a root\n\n    this._roots.forEach(function (selector) {\n      RelayReferenceMarker.mark(_this12._recordSource, selector, references, connectionReferences, function (id) {\n        return _this12.getConnectionEvents_UNSTABLE(id);\n      }, _this12._operationLoader);\n    });\n\n    if (references.size === 0) {\n      // Short-circuit if *nothing* is referenced\n      this._recordSource.clear();\n    } else {\n      // Evict any unreferenced nodes\n      var storeIDs = this._recordSource.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var dataID = storeIDs[ii];\n\n        if (!references.has(dataID)) {\n          this._recordSource.remove(dataID);\n        }\n      }\n    }\n\n    if (connectionReferences.size === 0) {\n      this._connectionEvents.clear();\n    } else {\n      // Evict any unreferenced connections\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._connectionEvents.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var connectionID = _step.value;\n\n          if (!connectionReferences.has(connectionID)) {\n            this._connectionEvents[\"delete\"](connectionID);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  };\n\n  return RelayModernStore;\n}();\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n */\n\n\nfunction updateTargetFromSource(target, source, updatedRecordIDs) {\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs[dataID] = true;\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs[dataID] = true;\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs[dataID] = true;\n    } // don't add explicit undefined\n\n  }\n}\n\nRelayProfiler.instrumentMethods(RelayModernStore.prototype, {\n  lookup: 'RelayModernStore.prototype.lookup',\n  notify: 'RelayModernStore.prototype.notify',\n  publish: 'RelayModernStore.prototype.publish',\n  __gc: 'RelayModernStore.prototype.__gc'\n});\nmodule.exports = RelayModernStore;","map":null,"metadata":{},"sourceType":"script"}
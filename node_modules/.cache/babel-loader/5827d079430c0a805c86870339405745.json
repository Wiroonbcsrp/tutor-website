{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar RelayConnectionInterface = require('./RelayConnectionInterface');\n\nvar getRelayHandleKey = require('../../util/getRelayHandleKey');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('../../store/ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs\n\nvar NEXT_EDGE_INDEX = '__connection_next_edge_index';\n/**\n * @public\n *\n * A default runtime handler for connection fields that appends newly fetched\n * edges onto the end of a connection, regardless of the arguments used to fetch\n * those edges.\n */\n\nfunction update(store, payload) {\n  var _clientConnectionFiel;\n\n  var record = store.get(payload.dataID);\n\n  if (!record) {\n    return;\n  }\n\n  var _RelayConnectionInter = RelayConnectionInterface.get(),\n      EDGES = _RelayConnectionInter.EDGES,\n      END_CURSOR = _RelayConnectionInter.END_CURSOR,\n      HAS_NEXT_PAGE = _RelayConnectionInter.HAS_NEXT_PAGE,\n      HAS_PREV_PAGE = _RelayConnectionInter.HAS_PREV_PAGE,\n      PAGE_INFO = _RelayConnectionInter.PAGE_INFO,\n      PAGE_INFO_TYPE = _RelayConnectionInter.PAGE_INFO_TYPE,\n      START_CURSOR = _RelayConnectionInter.START_CURSOR;\n\n  var serverConnection = record.getLinkedRecord(payload.fieldKey);\n  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!serverConnection) {\n    record.setValue(null, payload.handleKey);\n    return;\n  } // In rare cases the handleKey field may be unset even though the client\n  // connection record exists, in this case new edges should still be merged\n  // into the existing client connection record (and the field reset to point\n  // to that record).\n\n\n  var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);\n  var clientConnectionField = record.getLinkedRecord(payload.handleKey);\n  var clientConnection = (_clientConnectionFiel = clientConnectionField) !== null && _clientConnectionFiel !== void 0 ? _clientConnectionFiel : store.get(clientConnectionID);\n  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!clientConnection) {\n    // Initial fetch with data: copy fields from the server record\n    var connection = store.create(clientConnectionID, serverConnection.getType());\n    connection.setValue(0, NEXT_EDGE_INDEX);\n    connection.copyFieldsFrom(serverConnection);\n    var serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (serverEdges) {\n      serverEdges = serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, connection, edge);\n      });\n      connection.setLinkedRecords(serverEdges, EDGES);\n    }\n\n    record.setLinkedRecord(connection, payload.handleKey);\n    clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);\n    clientPageInfo.setValue(false, HAS_NEXT_PAGE);\n    clientPageInfo.setValue(false, HAS_PREV_PAGE);\n    clientPageInfo.setValue(null, END_CURSOR);\n    clientPageInfo.setValue(null, START_CURSOR);\n\n    if (serverPageInfo) {\n      clientPageInfo.copyFieldsFrom(serverPageInfo);\n    }\n\n    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);\n  } else {\n    if (clientConnectionField == null) {\n      // If the handleKey field was unset but the client connection record\n      // existed, update the field to point to the record\n      record.setLinkedRecord(clientConnection, payload.handleKey);\n    }\n\n    var _connection = clientConnection; // Subsequent fetches:\n    // - updated fields on the connection\n    // - merge prev/next edges, de-duplicating by node id\n    // - synthesize page info fields\n\n    var _serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (_serverEdges) {\n      _serverEdges = _serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, _connection, edge);\n      });\n    }\n\n    var prevEdges = _connection.getLinkedRecords(EDGES);\n\n    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);\n\n    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields\n\n\n    if (prevEdges) {\n      _connection.setLinkedRecords(prevEdges, EDGES);\n    }\n\n    if (prevPageInfo) {\n      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);\n    }\n\n    var nextEdges = [];\n    var args = payload.args;\n\n    if (prevEdges && _serverEdges) {\n      if (args.after != null) {\n        // Forward pagination from the end of the connection: append edges\n        if (clientPageInfo && args.after === clientPageInfo.getValue(END_CURSOR)) {\n          var nodeIDs = new Set();\n          mergeEdges(prevEdges, nextEdges, nodeIDs);\n          mergeEdges(_serverEdges, nextEdges, nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayConnectionHandler: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;\n          return;\n        }\n      } else if (args.before != null) {\n        // Backward pagination from the start of the connection: prepend edges\n        if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {\n          var _nodeIDs = new Set();\n\n          mergeEdges(_serverEdges, nextEdges, _nodeIDs);\n          mergeEdges(prevEdges, nextEdges, _nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayConnectionHandler: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;\n          return;\n        }\n      } else {\n        // The connection was refetched from the beginning/end: replace edges\n        nextEdges = _serverEdges;\n      }\n    } else if (_serverEdges) {\n      nextEdges = _serverEdges;\n    } else {\n      nextEdges = prevEdges;\n    } // Update edges only if they were updated, the null check is\n    // for Flow (prevEdges could be null).\n\n\n    if (nextEdges != null && nextEdges !== prevEdges) {\n      _connection.setLinkedRecords(nextEdges, EDGES);\n    } // Page info should be updated even if no new edge were returned.\n\n\n    if (clientPageInfo && serverPageInfo) {\n      if (args.after == null && args.before == null) {\n        // The connection was refetched from the beginning/end: replace\n        // page_info\n        clientPageInfo.copyFieldsFrom(serverPageInfo);\n      } else if (args.before != null || args.after == null && args.last) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);\n        var startCursor = serverPageInfo.getValue(START_CURSOR);\n\n        if (typeof startCursor === 'string') {\n          clientPageInfo.setValue(startCursor, START_CURSOR);\n        }\n      } else if (args.after != null || args.before == null && args.first) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);\n        var endCursor = serverPageInfo.getValue(END_CURSOR);\n\n        if (typeof endCursor === 'string') {\n          clientPageInfo.setValue(endCursor, END_CURSOR);\n        }\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Given a record and the name of the schema field for which a connection was\n * fetched, returns the linked connection record.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * The `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = RelayConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   // Access fields on the connection:\n *   const edges = friends.getLinkedRecords('edges');\n * }\n * ```\n *\n * TODO: t15733312\n * Currently we haven't run into this case yet, but we need to add a `getConnections`\n * that returns an array of the connections under the same `key` regardless of the variables.\n */\n\n\nfunction getConnection(record, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  return record.getLinkedRecord(handleKey, filters);\n}\n/**\n * @public\n *\n * Inserts an edge after the given cursor, or at the end of the list if no\n * cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be appended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = RelayConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   RelayConnectionHandler.insertEdgeAfter(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeAfter(record, newEdge, cursor) {\n  var _RelayConnectionInter2 = RelayConnectionInterface.get(),\n      CURSOR = _RelayConnectionInter2.CURSOR,\n      EDGES = _RelayConnectionInter2.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = edges.concat(newEdge);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      nextEdges.push(edge);\n\n      if (edge == null) {\n        continue;\n      }\n\n      var edgeCursor = edge.getValue(CURSOR);\n\n      if (cursor === edgeCursor) {\n        nextEdges.push(newEdge);\n        foundCursor = true;\n      }\n    }\n\n    if (!foundCursor) {\n      nextEdges.push(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Creates an edge for a connection record, given a node and edge type.\n */\n\n\nfunction createEdge(store, record, node, edgeType) {\n  var _RelayConnectionInter3 = RelayConnectionInterface.get(),\n      NODE = _RelayConnectionInter3.NODE; // An index-based client ID could easily conflict (unless it was\n  // auto-incrementing, but there is nowhere to the store the id)\n  // Instead, construct a client ID based on the connection ID and node ID,\n  // which will only conflict if the same node is added to the same connection\n  // twice. This is acceptable since the `insertEdge*` functions ignore\n  // duplicates.\n\n\n  var edgeID = generateClientID(record.getDataID(), node.getDataID());\n  var edge = store.get(edgeID);\n\n  if (!edge) {\n    edge = store.create(edgeID, edgeType);\n  }\n\n  edge.setLinkedRecord(node, NODE);\n  return edge;\n}\n/**\n * @public\n *\n * Inserts an edge before the given cursor, or at the beginning of the list if\n * no cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be prepended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = RelayConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   RelayConnectionHandler.insertEdgeBefore(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeBefore(record, newEdge, cursor) {\n  var _RelayConnectionInter4 = RelayConnectionInterface.get(),\n      CURSOR = _RelayConnectionInter4.CURSOR,\n      EDGES = _RelayConnectionInter4.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = [newEdge].concat(edges);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n\n      if (edge != null) {\n        var edgeCursor = edge.getValue(CURSOR);\n\n        if (cursor === edgeCursor) {\n          nextEdges.push(newEdge);\n          foundCursor = true;\n        }\n      }\n\n      nextEdges.push(edge);\n    }\n\n    if (!foundCursor) {\n      nextEdges.unshift(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Remove any edges whose `node.id` matches the given id.\n */\n\n\nfunction deleteNode(record, nodeID) {\n  var _RelayConnectionInter5 = RelayConnectionInterface.get(),\n      EDGES = _RelayConnectionInter5.EDGES,\n      NODE = _RelayConnectionInter5.NODE;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    return;\n  }\n\n  var nextEdges;\n\n  for (var ii = 0; ii < edges.length; ii++) {\n    var edge = edges[ii];\n    var node = edge && edge.getLinkedRecord(NODE);\n\n    if (node != null && node.getDataID() === nodeID) {\n      if (nextEdges === undefined) {\n        nextEdges = edges.slice(0, ii);\n      }\n    } else if (nextEdges !== undefined) {\n      nextEdges.push(edge);\n    }\n  }\n\n  if (nextEdges !== undefined) {\n    record.setLinkedRecords(nextEdges, EDGES);\n  }\n}\n/**\n * @internal\n *\n * Creates a copy of an edge with a unique ID based on per-connection-instance\n * incrementing edge index. This is necessary to avoid collisions between edges,\n * which can occur because (edge) client IDs are assigned deterministically\n * based on the path from the nearest node with an id.\n *\n * Example: if the first N edges of the same connection are refetched, the edges\n * from the second fetch will be assigned the same IDs as the first fetch, even\n * though the nodes they point to may be different (or the same and in different\n * order).\n */\n\n\nfunction buildConnectionEdge(store, connection, edge) {\n  if (edge == null) {\n    return edge;\n  }\n\n  var _RelayConnectionInter6 = RelayConnectionInterface.get(),\n      EDGES = _RelayConnectionInter6.EDGES;\n\n  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);\n  !(typeof edgeIndex === 'number') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;\n  var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);\n  var connectionEdge = store.create(edgeID, edge.getType());\n  connectionEdge.copyFieldsFrom(edge);\n  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);\n  return connectionEdge;\n}\n/**\n * @internal\n *\n * Adds the source edges to the target edges, skipping edges with\n * duplicate node ids.\n */\n\n\nfunction mergeEdges(sourceEdges, targetEdges, nodeIDs) {\n  var _RelayConnectionInter7 = RelayConnectionInterface.get(),\n      NODE = _RelayConnectionInter7.NODE;\n\n  for (var ii = 0; ii < sourceEdges.length; ii++) {\n    var edge = sourceEdges[ii];\n\n    if (!edge) {\n      continue;\n    }\n\n    var node = edge.getLinkedRecord(NODE);\n    var nodeID = node && node.getDataID();\n\n    if (nodeID) {\n      if (nodeIDs.has(nodeID)) {\n        continue;\n      }\n\n      nodeIDs.add(nodeID);\n    }\n\n    targetEdges.push(edge);\n  }\n}\n\nmodule.exports = {\n  buildConnectionEdge: buildConnectionEdge,\n  createEdge: createEdge,\n  deleteNode: deleteNode,\n  getConnection: getConnection,\n  insertEdgeAfter: insertEdgeAfter,\n  insertEdgeBefore: insertEdgeBefore,\n  update: update\n};","map":null,"metadata":{},"sourceType":"script"}